a2_dz = cbind(rnorm(n_dz, e_a2_dz_twin1, sqrt((2/var_a + 1/var_e)^-1)),
rnorm(n_dz, e_a2_dz_twin2, sqrt((2/var_a + 1/var_e)^-1)))
#3. Sample variance components:
alpha_tilde_c = alpha_gamma + n/2
beta_tilde_c = beta_c_gamma + 0.5 *  sum( (c(c_mz, c_dz)^2) )
var_c = rinvgamma(1, alpha_tilde_c, beta_tilde_c)
alpha_tilde_e = alpha_gamma + n
beta_tilde_e =  beta_gamma + (0.5* sum( (y_dz - a2_dz - cbind(x_b_dz_twin1, x_b_dz_twin2))^2)) +
(0.5 *  sum( (y_mz - a_mz - cbind(x_b_mz_twin1, x_b_mz_twin2))^2))
var_e = rinvgamma(1, alpha_tilde_e, beta_tilde_e)
alpha_tilde_a = alpha_gamma + 1.5*n_dz + 0.5*n_mz
beta_tilde_a = beta_gamma + (sum((a1_dz - a2_dz[,1])^2)) + (sum((a1_dz - a2_dz[,2])^2)) +
(0.5 * sum( (a_mz - c_mz)^2)) + sum( (a1_dz - c_dz)^2)
var_a = rinvgamma(1, alpha_tilde_a, beta_tilde_a)
#Set rest of parameters back to true parameter:
#         var_a = 0.5; #klopt sowieso
#         var_c = 0.3; #klopt sowieso
#         var_e = 0.2
#c_mz = true_c_mz #klopt sowieso
#c_dz = true_c_dz #klopt sowieso
a_mz = true_a_mz
#a1_dz = true_a1_dz
a2_dz = true_a2_dz
#Store parameter estimates:
if( t>burnin && (t-burnin)%%skip == 0 ) {
#print(paste("Iteration Number",t))
tt = tt+1
#store_a_mz[,tt] = a_mz
#store_c_mz[,tt] = c_mz
#store_a1_dz[,tt] = a1_dz
#store_a2_dz[,,tt] = a2_dz
#store_c_dz[,tt] = c_dz
store_var_a[tt] = var_a
store_var_c[tt] = var_c
store_var_e[tt] = var_e
}
}# n_iterations
return(  list(
#a_mz = store_a_mz,
#c_mz = store_c_mz,
#a1_dz = store_a1_dz,
#a2_dz = store_a2_dz,
#c_dz = store_c_dz,
var_a = store_var_a,
var_c = store_var_c,
var_e = store_var_e
) )
}
bla = mcmc(y_mz = y_mz, y_dz = y_dz, n_iterations = 10000, burnin = 5000, skip = 1,
beta = beta, n_var = 3, cov_mz = cov_mz, cov_dz = cov_dz)
mean(bla$var_a)
mean(bla$var_c)
mean(bla$var_e)
plot(bla$var_e, type = "l")
plot(bla$var_c, type = "l")
plot(bla$var_a, type = "l")
mcmc <- function(y_mz, y_dz, n_iterations, burnin, skip, beta, n_var, cov_mz, cov_dz){
#Install packages when necessary:
if(!require(MCMCpack)){ install.packages('MCMCpack'); require(MCMCpack)}
if(!require(R.utils)){ install.packages('R.utils'); require(R.utils)}
#Prior values variance components
alpha_gamma = 1
beta_gamma = 1
beta_c_gamma = 0.5
#Variables
n_mz = nrow(y_mz) #Number of MZ twin pairs
n_dz = nrow(y_dz) #Number of DZ twin pairs
n = n_mz + n_dz
pb = txtProgressBar(min = 0, max = n_iterations, style = 3, width = 50)
n_save = floor((n_iterations-burnin)/skip) #Number of samples to be stored
#n_save = 3 #to test
#STORE-variables:
store_a_mz = matrix(NA, n_mz, n_save)
store_c_mz = matrix(NA, n_mz, n_save)
store_a1_dz = matrix(NA, n_dz, n_save)
store_a2_dz = array(NA, c(n_dz, 2, n_save))
store_c_dz = matrix(NA, n_dz, n_save)
store_var_a = rep(NA, n_save)
store_var_c = rep(NA, n_save)
store_var_e = rep(NA, n_save)
store_beta = matrix(NA, n_save, n_var)
#Define start values:
var_a = runif(1,0.1, 0.9)
var_c = runif(1,0.1, 0.9)
var_e = runif(1,0.1, 0.9)
c_mz = rnorm(n_mz, 0, sqrt(var_c))
a_mz = rnorm(n_mz, c_mz, sqrt(var_a))
c_dz = rnorm(n_dz, 0, sqrt(var_c))
a1_dz = rnorm(n_dz, c_dz, sqrt(0.5 * var_a))
a2_dz = cbind(rnorm(n_dz, a1_dz, sqrt(0.5 * var_a)),
rnorm(n_dz, a1_dz, sqrt(0.5 * var_a)))
beta = rnorm(n_var, 0, 1)
#For each parameter, store start value(s) at first position of store vector:
store_a_mz[,1] = a_mz
store_c_mz[,1] = c_mz
store_a1_dz[,1] = a1_dz
store_a2_dz[,,1] = a2_dz
store_c_dz[,1] = c_dz
store_var_a[1] = var_a
store_var_c[1] = var_c
store_var_e[1] = var_e
store_beta[1,] = beta #each row = 1 iteration
#Begin with sampling procedure
tt = 0
for (t in 1:n_iterations){
#Save processing time and create progress bar:
ptm = proc.time()
setTxtProgressBar(pb, t)
#Voorbereiden sampelen (calculate xb MZ twin1+twin2, xb DZ twin1+twin2)
x_b_mz_twin1 = apply(cov_mz[,1:n_var], 1, function(x) x %*% beta)
x_b_mz_twin2 = apply(cov_mz[,(n_var+1):(2*n_var)], 1, function(x) x %*% beta)
x_b_dz_twin1 = apply(cov_dz[,1:n_var], 1, function(x) x %*% beta)
x_b_dz_twin2 = apply(cov_dz[,(n_var+1):(2*n_var)], 1, function(x) x %*% beta)
################# SAMPLING #################################
#1. Sample C_i and A_i for MZ twins:
e_c_mz = (1/var_a + 1/var_c)^-1 * (a_mz/var_a)
c_mz = rnorm(n_mz, e_c_mz, sqrt( (1/var_c + 1/var_a)^-1) )
e_a_mz = (2/var_e + 1/var_a)^-1 * ( (y_mz[,1]+y_mz[,2]-x_b_mz_twin1-x_b_mz_twin2)/var_e + c_mz/var_a)
a_mz = rnorm(n_mz, e_a_mz, sqrt((1/var_a + 2/var_e)^-1))
#2. Sample C_i, A1_i and A2_ij for DZ twins:
e_c_dz = (2/var_a + 1/var_c)^-1 * ( (2*a1_dz)/var_a )
c_dz = rnorm(n_dz, e_c_dz, sqrt((2/var_a + 1/var_c)^-1))
a1_dz = rnorm(n_dz, 1/3 * ( 2 * apply(a2_dz, 1, mean) + c_dz), sqrt(var_a/6))
e_a2_dz_twin1 = (1/var_e + 2/var_a)^-1 * ( (y_dz[,1]-x_b_dz_twin1)/var_e + (2*a1_dz)/var_a)
e_a2_dz_twin2 = (1/var_e + 2/var_a)^-1 * ( (y_dz[,2]-x_b_dz_twin1)/var_e + (2*a1_dz)/var_a)
a2_dz = cbind(rnorm(n_dz, e_a2_dz_twin1, sqrt((2/var_a + 1/var_e)^-1)),
rnorm(n_dz, e_a2_dz_twin2, sqrt((2/var_a + 1/var_e)^-1)))
#3. Sample variance components:
alpha_tilde_c = alpha_gamma + n/2
beta_tilde_c = beta_c_gamma + 0.5 *  sum( (c(c_mz, c_dz)^2) )
var_c = rinvgamma(1, alpha_tilde_c, beta_tilde_c)
alpha_tilde_e = alpha_gamma + n
beta_tilde_e =  beta_gamma + (0.5* sum( (y_dz - a2_dz - cbind(x_b_dz_twin1, x_b_dz_twin2))^2)) +
(0.5 *  sum( (y_mz - a_mz - cbind(x_b_mz_twin1, x_b_mz_twin2))^2))
#var_e = rinvgamma(1, alpha_tilde_e, beta_tilde_e)
alpha_tilde_a = alpha_gamma + 1.5*n_dz + 0.5*n_mz
beta_tilde_a = beta_gamma + (sum((a1_dz - a2_dz[,1])^2)) + (sum((a1_dz - a2_dz[,2])^2)) +
(0.5 * sum( (a_mz - c_mz)^2)) + sum( (a1_dz - c_dz)^2)
var_a = rinvgamma(1, alpha_tilde_a, beta_tilde_a)
#Set rest of parameters back to true parameter:
#         var_a = 0.5; #klopt sowieso
#         var_c = 0.3; #klopt sowieso
var_e = 0.2
#c_mz = true_c_mz #klopt sowieso
#c_dz = true_c_dz #klopt sowieso
#a_mz = true_a_mz
#a1_dz = true_a1_dz
a2_dz = true_a2_dz
#Store parameter estimates:
if( t>burnin && (t-burnin)%%skip == 0 ) {
#print(paste("Iteration Number",t))
tt = tt+1
#store_a_mz[,tt] = a_mz
#store_c_mz[,tt] = c_mz
#store_a1_dz[,tt] = a1_dz
#store_a2_dz[,,tt] = a2_dz
#store_c_dz[,tt] = c_dz
store_var_a[tt] = var_a
store_var_c[tt] = var_c
store_var_e[tt] = var_e
}
}# n_iterations
return(  list(
#a_mz = store_a_mz,
#c_mz = store_c_mz,
#a1_dz = store_a1_dz,
#a2_dz = store_a2_dz,
#c_dz = store_c_dz,
var_a = store_var_a,
var_c = store_var_c,
var_e = store_var_e
) )
}
bla = mcmc(y_mz = y_mz, y_dz = y_dz, n_iterations = 10000, burnin = 5000, skip = 1,
beta = beta, n_var = 3, cov_mz = cov_mz, cov_dz = cov_dz)
mean(bla$var_a)
mean(bla$var_c)
mean(bla$var_e)
mcmc <- function(y_mz, y_dz, n_iterations, burnin, skip, beta, n_var, cov_mz, cov_dz){
#Install packages when necessary:
if(!require(MCMCpack)){ install.packages('MCMCpack'); require(MCMCpack)}
if(!require(R.utils)){ install.packages('R.utils'); require(R.utils)}
#Prior values variance components
alpha_gamma = 1
beta_gamma = 1
beta_c_gamma = 0.5
#Variables
n_mz = nrow(y_mz) #Number of MZ twin pairs
n_dz = nrow(y_dz) #Number of DZ twin pairs
n = n_mz + n_dz
pb = txtProgressBar(min = 0, max = n_iterations, style = 3, width = 50)
n_save = floor((n_iterations-burnin)/skip) #Number of samples to be stored
#n_save = 3 #to test
#STORE-variables:
store_a_mz = matrix(NA, n_mz, n_save)
store_c_mz = matrix(NA, n_mz, n_save)
store_a1_dz = matrix(NA, n_dz, n_save)
store_a2_dz = array(NA, c(n_dz, 2, n_save))
store_c_dz = matrix(NA, n_dz, n_save)
store_var_a = rep(NA, n_save)
store_var_c = rep(NA, n_save)
store_var_e = rep(NA, n_save)
store_beta = matrix(NA, n_save, n_var)
#Define start values:
var_a = runif(1,0.1, 0.9)
var_c = runif(1,0.1, 0.9)
var_e = runif(1,0.1, 0.9)
c_mz = rnorm(n_mz, 0, sqrt(var_c))
a_mz = rnorm(n_mz, c_mz, sqrt(var_a))
c_dz = rnorm(n_dz, 0, sqrt(var_c))
a1_dz = rnorm(n_dz, c_dz, sqrt(0.5 * var_a))
a2_dz = cbind(rnorm(n_dz, a1_dz, sqrt(0.5 * var_a)),
rnorm(n_dz, a1_dz, sqrt(0.5 * var_a)))
beta = rnorm(n_var, 0, 1)
#For each parameter, store start value(s) at first position of store vector:
store_a_mz[,1] = a_mz
store_c_mz[,1] = c_mz
store_a1_dz[,1] = a1_dz
store_a2_dz[,,1] = a2_dz
store_c_dz[,1] = c_dz
store_var_a[1] = var_a
store_var_c[1] = var_c
store_var_e[1] = var_e
store_beta[1,] = beta #each row = 1 iteration
#Begin with sampling procedure
tt = 0
for (t in 1:n_iterations){
#Save processing time and create progress bar:
ptm = proc.time()
setTxtProgressBar(pb, t)
#Voorbereiden sampelen (calculate xb MZ twin1+twin2, xb DZ twin1+twin2)
x_b_mz_twin1 = apply(cov_mz[,1:n_var], 1, function(x) x %*% beta)
x_b_mz_twin2 = apply(cov_mz[,(n_var+1):(2*n_var)], 1, function(x) x %*% beta)
x_b_dz_twin1 = apply(cov_dz[,1:n_var], 1, function(x) x %*% beta)
x_b_dz_twin2 = apply(cov_dz[,(n_var+1):(2*n_var)], 1, function(x) x %*% beta)
################# SAMPLING #################################
#1. Sample C_i and A_i for MZ twins:
e_c_mz = (1/var_a + 1/var_c)^-1 * (a_mz/var_a)
c_mz = rnorm(n_mz, e_c_mz, sqrt( (1/var_c + 1/var_a)^-1) )
e_a_mz = (2/var_e + 1/var_a)^-1 * ( (y_mz[,1]+y_mz[,2]-x_b_mz_twin1-x_b_mz_twin2)/var_e + c_mz/var_a)
#a_mz = rnorm(n_mz, e_a_mz, sqrt((1/var_a + 2/var_e)^-1))
#2. Sample C_i, A1_i and A2_ij for DZ twins:
e_c_dz = (2/var_a + 1/var_c)^-1 * ( (2*a1_dz)/var_a )
c_dz = rnorm(n_dz, e_c_dz, sqrt((2/var_a + 1/var_c)^-1))
a1_dz = rnorm(n_dz, 1/3 * ( 2 * apply(a2_dz, 1, mean) + c_dz), sqrt(var_a/6))
e_a2_dz_twin1 = (1/var_e + 2/var_a)^-1 * ( (y_dz[,1]-x_b_dz_twin1)/var_e + (2*a1_dz)/var_a)
e_a2_dz_twin2 = (1/var_e + 2/var_a)^-1 * ( (y_dz[,2]-x_b_dz_twin1)/var_e + (2*a1_dz)/var_a)
#a2_dz = cbind(rnorm(n_dz, e_a2_dz_twin1, sqrt((2/var_a + 1/var_e)^-1)),
#              rnorm(n_dz, e_a2_dz_twin2, sqrt((2/var_a + 1/var_e)^-1)))
#3. Sample variance components:
alpha_tilde_c = alpha_gamma + n/2
beta_tilde_c = beta_c_gamma + 0.5 *  sum( (c(c_mz, c_dz)^2) )
var_c = rinvgamma(1, alpha_tilde_c, beta_tilde_c)
alpha_tilde_e = alpha_gamma + n
beta_tilde_e =  beta_gamma + (0.5* sum( (y_dz - a2_dz - cbind(x_b_dz_twin1, x_b_dz_twin2))^2)) +
(0.5 *  sum( (y_mz - a_mz - cbind(x_b_mz_twin1, x_b_mz_twin2))^2))
#var_e = rinvgamma(1, alpha_tilde_e, beta_tilde_e)
alpha_tilde_a = alpha_gamma + 1.5*n_dz + 0.5*n_mz
beta_tilde_a = beta_gamma + (sum((a1_dz - a2_dz[,1])^2)) + (sum((a1_dz - a2_dz[,2])^2)) +
(0.5 * sum( (a_mz - c_mz)^2)) + sum( (a1_dz - c_dz)^2)
var_a = rinvgamma(1, alpha_tilde_a, beta_tilde_a)
#Set rest of parameters back to true parameter:
#         var_a = 0.5; #klopt sowieso
#         var_c = 0.3; #klopt sowieso
var_e = 0.2
#c_mz = true_c_mz #klopt sowieso
#c_dz = true_c_dz #klopt sowieso
a_mz = true_a_mz
#a1_dz = true_a1_dz
#a2_dz = true_a2_dz
#Store parameter estimates:
if( t>burnin && (t-burnin)%%skip == 0 ) {
#print(paste("Iteration Number",t))
tt = tt+1
#store_a_mz[,tt] = a_mz
#store_c_mz[,tt] = c_mz
#store_a1_dz[,tt] = a1_dz
#store_a2_dz[,,tt] = a2_dz
#store_c_dz[,tt] = c_dz
store_var_a[tt] = var_a
store_var_c[tt] = var_c
store_var_e[tt] = var_e
}
}# n_iterations
return(  list(
#a_mz = store_a_mz,
#c_mz = store_c_mz,
#a1_dz = store_a1_dz,
#a2_dz = store_a2_dz,
#c_dz = store_c_dz,
var_a = store_var_a,
var_c = store_var_c,
var_e = store_var_e
) )
}
bla = mcmc(y_mz = y_mz, y_dz = y_dz, n_iterations = 5000, burnin = 2000, skip = 1,
beta = beta, n_var = 3, cov_mz = cov_mz, cov_dz = cov_dz)
mean(bla$var_a)
mean(bla$var_c)
mean(bla$var_e)
mean(bla$var_a)
mean(bla$var_c)
mcmc <- function(y_mz, y_dz, n_iterations, burnin, skip, beta, n_var, cov_mz, cov_dz){
#Install packages when necessary:
if(!require(MCMCpack)){ install.packages('MCMCpack'); require(MCMCpack)}
if(!require(R.utils)){ install.packages('R.utils'); require(R.utils)}
#Prior values variance components
alpha_gamma = 1
beta_gamma = 1
beta_c_gamma = 0.5
#Variables
n_mz = nrow(y_mz) #Number of MZ twin pairs
n_dz = nrow(y_dz) #Number of DZ twin pairs
n = n_mz + n_dz
pb = txtProgressBar(min = 0, max = n_iterations, style = 3, width = 50)
n_save = floor((n_iterations-burnin)/skip) #Number of samples to be stored
#n_save = 3 #to test
#STORE-variables:
store_a_mz = matrix(NA, n_mz, n_save)
store_c_mz = matrix(NA, n_mz, n_save)
store_a1_dz = matrix(NA, n_dz, n_save)
store_a2_dz = array(NA, c(n_dz, 2, n_save))
store_c_dz = matrix(NA, n_dz, n_save)
store_var_a = rep(NA, n_save)
store_var_c = rep(NA, n_save)
store_var_e = rep(NA, n_save)
store_beta = matrix(NA, n_save, n_var)
#Define start values:
var_a = runif(1,0.1, 0.9)
var_c = runif(1,0.1, 0.9)
var_e = runif(1,0.1, 0.9)
c_mz = rnorm(n_mz, 0, sqrt(var_c))
a_mz = rnorm(n_mz, c_mz, sqrt(var_a))
c_dz = rnorm(n_dz, 0, sqrt(var_c))
a1_dz = rnorm(n_dz, c_dz, sqrt(0.5 * var_a))
a2_dz = cbind(rnorm(n_dz, a1_dz, sqrt(0.5 * var_a)),
rnorm(n_dz, a1_dz, sqrt(0.5 * var_a)))
beta = rnorm(n_var, 0, 1)
#For each parameter, store start value(s) at first position of store vector:
store_a_mz[,1] = a_mz
store_c_mz[,1] = c_mz
store_a1_dz[,1] = a1_dz
store_a2_dz[,,1] = a2_dz
store_c_dz[,1] = c_dz
store_var_a[1] = var_a
store_var_c[1] = var_c
store_var_e[1] = var_e
store_beta[1,] = beta #each row = 1 iteration
#Begin with sampling procedure
tt = 0
for (t in 1:n_iterations){
#Save processing time and create progress bar:
ptm = proc.time()
setTxtProgressBar(pb, t)
#Voorbereiden sampelen (calculate xb MZ twin1+twin2, xb DZ twin1+twin2)
x_b_mz_twin1 = apply(cov_mz[,1:n_var], 1, function(x) x %*% beta)
x_b_mz_twin2 = apply(cov_mz[,(n_var+1):(2*n_var)], 1, function(x) x %*% beta)
x_b_dz_twin1 = apply(cov_dz[,1:n_var], 1, function(x) x %*% beta)
x_b_dz_twin2 = apply(cov_dz[,(n_var+1):(2*n_var)], 1, function(x) x %*% beta)
################# SAMPLING #################################
#1. Sample C_i and A_i for MZ twins:
e_c_mz = (1/var_a + 1/var_c)^-1 * (a_mz/var_a)
c_mz = rnorm(n_mz, e_c_mz, sqrt( (1/var_c + 1/var_a)^-1) )
e_a_mz = (2/var_e + 1/var_a)^-1 * ( (y_mz[,1]+y_mz[,2]-x_b_mz_twin1-x_b_mz_twin2)/var_e + c_mz/var_a)
#a_mz = rnorm(n_mz, e_a_mz, sqrt((1/var_a + 2/var_e)^-1))
#2. Sample C_i, A1_i and A2_ij for DZ twins:
e_c_dz = (2/var_a + 1/var_c)^-1 * ( (2*a1_dz)/var_a )
c_dz = rnorm(n_dz, e_c_dz, sqrt((2/var_a + 1/var_c)^-1))
a1_dz = rnorm(n_dz, 1/3 * ( 2 * apply(a2_dz, 1, mean) + c_dz), sqrt(var_a/6))
e_a2_dz_twin1 = (1/var_e + 2/var_a)^-1 * ( (y_dz[,1]-x_b_dz_twin1)/var_e + (2*a1_dz)/var_a)
e_a2_dz_twin2 = (1/var_e + 2/var_a)^-1 * ( (y_dz[,2]-x_b_dz_twin1)/var_e + (2*a1_dz)/var_a)
#a2_dz = cbind(rnorm(n_dz, e_a2_dz_twin1, sqrt((2/var_a + 1/var_e)^-1)),
#              rnorm(n_dz, e_a2_dz_twin2, sqrt((2/var_a + 1/var_e)^-1)))
#3. Sample variance components:
alpha_tilde_c = alpha_gamma + n/2
beta_tilde_c = beta_c_gamma + 0.5 *  sum( (c(c_mz, c_dz)^2) )
var_c = rinvgamma(1, alpha_tilde_c, beta_tilde_c)
alpha_tilde_e = alpha_gamma + n
beta_tilde_e =  beta_gamma + (0.5* sum( (y_dz - a2_dz - cbind(x_b_dz_twin1, x_b_dz_twin2))^2)) +
(0.5 *  sum( (y_mz - a_mz - cbind(x_b_mz_twin1, x_b_mz_twin2))^2))
#var_e = rinvgamma(1, alpha_tilde_e, beta_tilde_e)
alpha_tilde_a = alpha_gamma + 1.5*n_dz + 0.5*n_mz
beta_tilde_a = beta_gamma + (sum((a1_dz - a2_dz[,1])^2)) + (sum((a1_dz - a2_dz[,2])^2)) +
(0.5 * sum( (a_mz - c_mz)^2)) + sum( (a1_dz - c_dz)^2)
var_a = rinvgamma(1, alpha_tilde_a, beta_tilde_a)
#Set rest of parameters back to true parameter:
#         var_a = 0.5; #klopt sowieso
#         var_c = 0.3; #klopt sowieso
var_e = 0.2
#c_mz = true_c_mz #klopt sowieso
#c_dz = true_c_dz #klopt sowieso
a_mz = true_a_mz
#a1_dz = true_a1_dz
a2_dz = true_a2_dz
#Store parameter estimates:
if( t>burnin && (t-burnin)%%skip == 0 ) {
#print(paste("Iteration Number",t))
tt = tt+1
#store_a_mz[,tt] = a_mz
#store_c_mz[,tt] = c_mz
#store_a1_dz[,tt] = a1_dz
#store_a2_dz[,,tt] = a2_dz
#store_c_dz[,tt] = c_dz
store_var_a[tt] = var_a
store_var_c[tt] = var_c
store_var_e[tt] = var_e
}
}# n_iterations
return(  list(
#a_mz = store_a_mz,
#c_mz = store_c_mz,
#a1_dz = store_a1_dz,
#a2_dz = store_a2_dz,
#c_dz = store_c_dz,
var_a = store_var_a,
var_c = store_var_c,
var_e = store_var_e
) )
}
bla = mcmc(y_mz = y_mz, y_dz = y_dz, n_iterations = 5000, burnin = 2000, skip = 1,
beta = beta, n_var = 3, cov_mz = cov_mz, cov_dz = cov_dz)
mean(bla$var_a)
mean(bla$var_c)
mean(bla$var_e)
plot(bla$var_e, type = "l")
plot(bla$var_c, type = "l")
plot(bla$var_a, type = "l")
?mvrnorm
?mvrnorm
install.packages(“devtools”)
install.packages(“devtools”)
?install.packages
install.packages(“devtools”)
install.packages("rjags")
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
library(devtools)
install_github("ingaschwabe/BayesTwin")
library(BayesTwin)
.libPaths()
.libPaths()
library(coda)
?summary.mcmc
summary.mcmc()
summary.mcmc
summary.mcmc()
install.packages("rjags");library(rjags)
setwd("/Users/inga/Dropbox/MCMC/github") #set working directory
setwd("C:/Users/schwabei/Dropbox/MCMC/github") #set working directory
install.packages("devtools")
library(devtools)
install_github("ingaschwabe/BayesTwin")
library(BayesTwin)
?simulate_twin_data
twin_data = simulate_twin_data(nmz = 500, ndz = 700, var_a = 0.5,
var_c = 0.3, var_e = 0.2, model = "ACE",
n_items = 30, n_var = 0)
head(twin_data)
names(twin_data)
jagsdata = list("n_mz" = 500, "n_dz" = 700,
"Ymz" = twin_data$y_mz,
"Ydz" = twin_data$y_dz)
jags <- jags.model("twin_mdoel_jags.txt", jagsdata, inits = NULL, n.chains = 1, quiet=FALSE)
jags <- jags.model("twin_model_jags.txt", jagsdata, inits = NULL, n.chains = 1, quiet=FALSE)
setwd("C:/Users/schwabei/Dropbox/MCMC/github/Part 2 JAGS") #set working directory
jags <- jags.model("twin_model_jags.txt", jagsdata, inits = NULL, n.chains = 1, quiet=FALSE)
jagsdata = list("n_mz" = 500, "n_dz" = 700, "n_items" = 30,
"Ymz" = twin_data$y_mz,
"Ydz" = twin_data$y_dz)
#Het model staat in jags.txt, we gebruiken geen eigen start waarden (inits = NULL) en 1 markov chain:
jags <- jags.model("twin_model_jags.txt", jagsdata, inits = NULL, n.chains = 1, quiet=FALSE)
jagsdata = list("n_mz" = 500, "n_dz" = 700, "n_items" = 30,
"Ymz" = twin_data$y_mz,
"Ydz" = twin_data$y_dz)
#Het model staat in jags.txt, we gebruiken geen eigen start waarden (inits = NULL) en 1 markov chain:
jags <- jags.model("twin_model_jags.txt", jagsdata, inits = NULL, n.chains = 1, quiet=FALSE)
#Het model staat in jags.txt, we gebruiken geen eigen start waarden (inits = NULL) en 1 markov chain:
jags <- jags.model("twin_model_jags.txt", jagsdata, inits = NULL, n.chains = 1, quiet=FALSE)
update(jags, 100)
jags <- jags.model("twin_model_jags.txt", jagsdata, inits = NULL, n.chains = 1, quiet=FALSE)
update(jags, 100)
out <- jags.samples(jags, c("b", "var_a", "var_c", "var_e"), 100)
jagsdata = list("n_mz" = 500, "n_dz" = 700, "n_items" = 30,
"Ymz" = twin_data$y_mz,
"Ydz" = twin_data$y_dz)
#Het model staat in jags.txt, we gebruiken geen eigen start waarden (inits = NULL) en 1 markov chain:
jags <- jags.model("twin_model_jags.txt", jagsdata, inits = NULL, n.chains = 1, quiet=FALSE)
update(jags, 100)
out <- jags.samples(jags, c("b", "tau_c", "tau_e", "tau_a"), 100)
plot(1/out$var_a[,,1])
plot(1/out$tau_a[,,1])
plot(1/out$tau_a[,,1], type = "l")
plot(1/out$tau_c[,,1], type = "l")
plot(1/out$var_e[,,1], type = "l")
plot(1/out$tau_e[,,1], type = "l")
plot(out$b[,,1]) #item parameter beta, item 1
plot(out$b[,,1], type = "l") #item parameter beta, item 1
plot(out$b[1,,1], type = "l") #item parameter beta, item 1
plot(out$b[12,,1], type = "l") #item parameter beta, item 12
1/out$tau_a
1/out$tau_c
1/out$tau_e
1/out$tau_a; sd(1/out$tau_a)
1/out$tau_c; sd(1/out$tau_c)
1/out$tau_e; sd(1/out$tau_e)
?HPD
HPD()
HPD(out$tau_a, 0.95)
HPD(1/out$tau_a, 0.95)
HPD(1/out$tau_c, 0.95)
HPD(1/out$tau_e, 0.95)
